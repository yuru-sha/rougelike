### 基本方針
- 簡潔で効率的なソースコードを書きます。
- ソースコードが読みやすく、メンテナンスしやすいソースコードを心がけます。
- コードの実行効率と保守性を高めるために、コードの可読性を向上させます。
- 単一責任の原則を守ります。
- イミュータブルな設計を心がけます。

### コードスタイルと構造
- コードの重複を避ける：再利用可能なコンポーネントにモジュール化します。
- 説明的な変数名を使用する：is_loading、has_errorのような補助動詞を用いた名前を使います。
- パフォーマンスを考慮：適切なデータ構造とアルゴリズムを選択します。
- 設定値は外部ファイルに分離し、ハードコーディングを避けます。
- 共通の定数は定数モジュールに定義します。
- 複雑なロジックには適切なデザインパターンを適用します。
- メソッドの長さは適切に保ちます（目安：30行以内）。
- 循環的複雑度を低く保ちます。

### /src以下のディレクトリ構造
- /src/core/: ゲームのコア機能
- /src/entities/: ゲームのエンティティ
- /src/utils/: ユーティリティ関数や定数
- /src/tests/: テストコード
- /src/config/: 設定ファイル
- /src/interfaces/: インターフェース定義
- /src/constants/: 定数定義
- /src/exceptions/: カスタム例外クラス
- /src/services/: ビジネスロジック
- /logs/: ログファイル

### 命名規則
- Python： Pythonスタイルガイド(PEP 8)に従う。
- Python: 変数名やメソッド名から冗長な部分を除く。
- Python: 適切な英単語と品詞で、責務が分かる名前をつける。
- JSON: キーはキャメルケース
- 定数: 大文字のスネークケース（例：MAX_ROOM_SIZE）
- クラス名: パスカルケース（例：GameEngine）
- メソッド名: スネークケース（例：update_position）
- プライベートメソッド: アンダースコアプレフィックス（例：_update_state）
- 例外クラス: Error/Exceptionサフィックス（例：InvalidStateError）
- インターフェース: Iプレフィックス（例：IRenderer）
- 抽象クラス: Abstractプレフィックス（例：AbstractEntity）

### インポート
- imoprtの記載はルールに従う。
- 標準ライブラリ、サードパーティライブラリ、ローカルモジュールの順に記載
- 各グループ間に空行を入れる
- アルファベット順に並べる
- 相対インポートは避け、絶対インポートを使用する
- 循環インポートを避ける
- 必要なモジュールのみをインポートする（*インポートを避ける）
- typing関連のインポートは別グループにする

### ドキュメント
- クラス、メソッド、関数には英語docstringをつけます。
- ソースコードのコメントは英語で記載します。
- コメントアウトは積極的に使い、コードの理解とメンテナンスに役立てます。
- 関数、メソッドには型ヒントをつけます。

### ロギング
- ログレベルを適切に使い分ける（DEBUG, INFO, WARNING, ERROR, CRITICAL）
- 例外発生時は必ずスタックトレースをログに記録
- ログメッセージは明確で追跡可能な情報を含める
- パフォーマンスに影響するログは条件付きで出力

### エラー処理
- カスタム例外クラスを定義して使用
- 例外は適切な粒度でキャッチ
- 例外メッセージは具体的な情報を含める
- リソースの解放は必ずfinallyブロックで行う

### テスト
- ユニットテストは機能単位で作成
- テストケースは境界値を含める
- モックを使用して外部依存を分離
- テストカバレッジは80%以上を目標

### 依存性管理
- injectorを使用して依存性注入を行います。
- インターフェースを定義し、実装との分離を行います。
- テスト時にモックに置き換えやすい設計にします。

### ターミナル操作
- blessedを使用してターミナルのサポートを行います。
- プラットフォーム依存の処理を抽象化します。
- ターミナル操作のユーティリティ関数を作成します。
